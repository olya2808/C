#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>//библиотека для ввода и вывода
#include<stdlib.h>//библиотека для работы со строками
#include<malloc.h>//библиотека для работы функции malloc
#include"Player.h"//заголовочный файл со структурой
#include"N.h"//заголовочный файл с глобальными переменными
void sort(const char*name)//функция для сортировки в файле
{
	int i,j,k,task,poz,order;//объявление целых перемннных
	FILE*f = fopen(name, "rt");//открытие файла
	if (!f)//проверка создания
	{
		printf("file can't be opened \n");//сообщение об ошибке
		return;//завершение программы
	}
	fseek(f, 0, SEEK_END);//перемещение каретки в конец файла
	n = (ftell(f)) / sizeof(player);//узнаем количество элементов в файле
	fseek(f, 0, SEEK_SET);//перемещение каретки в начало файла
	if (data != NULL)//проверка для очистки структуры
	{
		free(data);//очищение структуры
	}
	data = (player*)malloc(n * sizeof(player));//выделение памяти для структуры
	for (i = 0; i < n; i++)//цикл для записи данных из файла в структуру
	{
		fread(&data[i], sizeof(player), 1, f);//записываем в структуру данные, которые лежат в файле
	}
	fclose(f);//закрытие файла
	printf("By which parameter do you want to sort players?\n1)Name\n2)Surname\n3)Father's name\n4)Player's club\n5)Amplua\n6)Player's age\n7)Number of Player's plays\n8)Number of player's goals\n");//спрашиваем параметр, по которому будем сортировать
	scanf("%d", &task);//считываем параметр, по которому будем сортировать
	printf("\n");//табуляция для красивого вывода
	switch (task)//функция для сортировки по различным параметрам
	{
	case 1://случай для сортировки по имени
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].fio.imya, data[j + 1].fio.imya) > 0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 2://случай для сортировки по фамилии
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].fio.familia,data[j + 1].fio.familia)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 3://случай для сортировки по отчеству
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].fio.otchestvo,data[j + 1].fio.otchestvo)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 4://случай для сортировки по клубу
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].club, data[j + 1].club)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 5://случай для сортировки по амплуа
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].amplua,data[j + 1].amplua)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 6://случай для сортировки по возрасту
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].age,data[j + 1].age)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 7://случай для сортировки по количеству игр
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].plays, data[j + 1].plays)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	case 8://случай для сортировки по количеству голов
	{
		for (int i = 0; i < n - 1; i++)//цикл для первого прохода по массиву
		{
			for (int j = 0; j < n - i - 1; j++)//цикл для второго прохода по массиву
			{
				if (strcmp(data[j].goals, data[j + 1].goals)>0)//сравниваем соответствующие элементы
				{
					player tmp = data[j];//кладем j-тый элемент во временную структуру
					data[j] = data[j + 1];//кладем в j-тый элемент j+1 элемент
					data[j + 1] = tmp;//кладем в j+1 элемент временную структуру
				}
			}
		}
		break;//завершаем выполнение данного случая
	}
	}
	f = fopen(name, "wb");//открываем файл для записи заново
	for (i = 0; i < n; i++)//цикл для записи в файл
	{
		fwrite(&data[i], sizeof(player), 1, f);//запись в файл
	}
	fclose(f);//закрытие файла
	menu(name);//вызов функции меню
}
